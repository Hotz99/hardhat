{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-744d47382d233ab24860df8e4f9fd241397bdfb9",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ConsentManager.sol": "project/contracts/ConsentManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ConsentManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IConsentManager {\n    function grantConsent(\n        address lender,\n        bytes32[] calldata scopes,\n        uint256 durationDays\n    ) external returns (bytes32 consentId);\n\n    function revokeAllConsents(address lender) external;\n\n    function revokeConsentById(bytes32 consentId) external;\n\n    function checkConsent(\n        address borrower,\n        bytes32 scope\n    ) external view returns (bool);\n\n    function isConsentValid(bytes32 consentId) external view returns (bool);\n\n    // ---------------------------------------------\n    // Accessors\n    // ---------------------------------------------\n\n    function getScopes(bytes32 consentId)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getConsents(bytes32 consentId)\n        external\n        view\n        returns (\n            address borrower,\n            address lender,\n            uint256 startBlockTime,\n            uint256 expiryBlockTime,\n            bool isRevoked\n        );\n\n    function getBorrowerConsents(address borrower)\n        external\n        view\n        returns (bytes32[] memory);\n}\n\n\n/**\n * @title ConsentManager\n * @notice Manages borrower consent grants and validates authorization requests from lenders\n * @dev Implements scope-based consent with expiry times and revocation capability\n */\ncontract ConsentManager {\n    struct Consent {\n        address borrower;\n        address lender;\n        // hashed scope identifiers \n        // e.g.: keccak256(abi.encodePacked(\"credit_score\", \"income_bracket\", ...))\n        bytes32[] scopes;\n        uint256 startBlockTime;\n        uint256 expiryBlockTime;\n        bool isRevoked;\n        bool isValue;\n    }\n  \n    // borrowerAddress => consentIds[]\n    mapping(address => bytes32[]) public borrowerConsents;\n    // consentId => Consent\n    mapping(bytes32 => Consent) public consents;\n    \n    event ConsentGranted(\n        bytes32 indexed consentId,\n        address indexed borrower,\n        address indexed lender,\n        bytes32[] scopes,\n        uint256 startBlockTime,\n        uint256 expiryBlockTime\n    );\n    \n    event ConsentRevoked(\n        bytes32 indexed consentId,\n        address indexed borrower,\n        address indexed lender\n    );\n    \n    event ConsentQueried(\n        bytes32 indexed consentId,\n        address indexed querier,\n        bool authorized\n    );\n    \n    error UnauthorizedRevocation();\n    error ConsentAlreadyRevoked();\n    error ConsentExpired();\n    error ConsentNotFound();\n\n    /**\n     * @notice Grant consent to a lender for multiple scopes and duration\n     * @param lender Address of the lender receiving consent\n     * @param scopes Array of hashed scope identifiers (e.g., keccak256(abi.encodePacked(\"credit_score\")))\n     * @param durationSeconds Duration in seconds for which consent is valid\n     * @return consentId Unique identifier for this consent grant\n     */\n    function grantConsent(\n        address lender,\n        bytes32[] calldata scopes,\n        uint256 durationSeconds\n    ) external returns (bytes32 consentId) {\n        require(lender != address(0), \"Invalid lender address\");\n        require(scopes.length > 0, \"At least one scope required\");\n        require(durationSeconds > 0, \"Duration must be positive\");\n        \n        // Validate no zero scopes\n        for (uint256 i = 0; i < scopes.length; i++) {\n            require(scopes[i] != bytes32(0), \"Invalid scope\");\n        }\n        \n        uint256 startBlockTime = block.timestamp;\n        uint256 expiryBlockTime = block.timestamp + durationSeconds;\n        \n        consentId = keccak256(\n            abi.encodePacked(\n                // `msg.sender` is `borrower`\n                msg.sender,\n                lender,\n                scopes,\n                block.timestamp,\n                block.timestamp + durationSeconds,\n                block.number\n            )\n        );\n\n        // A Consent has to have a lender that's not address(0)\n        // To make sure the Consent being created doesn't exist, we make sure it's lender is the default address(0)\n        require(consents[consentId].lender == address(0), \"Consent already exists\");\n\n        consents[consentId] = Consent({\n            borrower: msg.sender,\n            lender: lender,\n            scopes: scopes,\n            startBlockTime: startBlockTime,\n            expiryBlockTime: expiryBlockTime,\n            isRevoked: false,\n            isValue: true\n        });\n        \n        borrowerConsents[msg.sender].push(consentId);\n        \n        emit ConsentGranted(consentId, msg.sender, lender, scopes, startBlockTime, expiryBlockTime);\n    }\n    \n    /**\n     * @notice Check if a specific consent is currently valid\n     * @param consentId The consent identifier to check\n     * @return bool True if consent exists, is not revoked, and not expired\n     */\n    function isConsentValid(bytes32 consentId) external view returns (bool) {\n        Consent storage consent = consents[consentId];\n        \n        if (consent.borrower == address(0)) {\n            return false;  // Consent doesn't exist\n        }\n        \n        if (consent.isRevoked) {\n            return false;  // Consent was revoked\n        }\n        \n        if (block.timestamp > consent.expiryBlockTime) {\n            return false;  // Consent expired\n        }\n        \n        return true;\n    }\n    \n    /**\n     * @notice Check authorization for a lender to access borrower's data with specific scope\n     * @dev Called by OffChainStore to validate consent before returning encrypted data\n     * @param borrower Address of the data owner\n     * @param scope The scope being requested\n     * @return bool True if valid consent exists from borrower to caller with requested scope\n     */\n    function checkConsent(\n        address borrower,   \n        bytes32 scope\n    ) external returns (bool) {\n        address lender = msg.sender;\n        \n        for (uint256 i = 0; i < borrowerConsents[borrower].length; i++) {\n            bytes32 consentId = borrowerConsents[borrower][i];\n            Consent storage consent = consents[consentId];\n            \n            if (consent.lender != lender || consent.isRevoked || block.timestamp > consent.expiryBlockTime) {\n                continue;\n            }\n            \n            bool scopeFound = false;\n            for (uint256 j = 0; j < consent.scopes.length; j++) {\n                if (consent.scopes[j] == scope) {\n                    scopeFound = true;\n                    break;\n                }\n            }\n            \n            if (scopeFound) {\n                emit ConsentQueried(consentId, lender, true);\n                return true;\n            }\n        }\n        \n        // No valid consent found for this scope\n        emit ConsentQueried(bytes32(0), lender, false);\n        return false;\n    }\n    \n    /**\n     * @notice Revoke all consents granted to a specific lender\n     * @param lender Address of the lender whose consents should be revoked\n     */\n    function revokeAllConsents(address lender) external {\n        require(lender != address(0), \"Invalid lender address\");\n        \n        bytes32[] storage userConsents = borrowerConsents[msg.sender];\n        \n        for (uint256 i = 0; i < userConsents.length; i++) {\n            bytes32 consentId = userConsents[i];\n            Consent storage consent = consents[consentId];\n            \n            if (consent.lender == lender && !consent.isRevoked) {\n                consent.isRevoked = true;\n                emit ConsentRevoked(consentId, msg.sender, lender);\n            }\n        }\n    }\n\n    /**\n     * @notice Revoke a specific consent by ID\n     * @param consentId The unique identifier of the consent to revoke\n     */\n    function revokeConsentById(bytes32 consentId) external {\n        Consent storage consent = consents[consentId];\n        \n        if (consent.borrower == address(0)) {\n            revert ConsentNotFound();\n        }\n        \n        if (consent.borrower != msg.sender) {\n            revert UnauthorizedRevocation();\n        }\n        \n        if (consent.isRevoked) {\n            revert ConsentAlreadyRevoked();\n        }\n        \n        consent.isRevoked = true;\n        emit ConsentRevoked(consentId, msg.sender, consent.lender);\n    }\n\n    function getScopes(bytes32 consentId) external view returns (bytes32[] memory) {\n        return consents[consentId].scopes;\n    }\n\n    function getBorrowerConsents(address borrower) external view returns (bytes32[] memory) {\n        return borrowerConsents[borrower];\n    }\n}\n"
      }
    }
  }
}