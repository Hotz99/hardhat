{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e9e1ce734e049f293821d9810e571525e8d92b23",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CreditRegistry.sol": "project/contracts/CreditRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AuditLog.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title IAuditLog\n * @notice Minimal audit logging interface used by ConsentManager and CreditRegistry.\n * @dev Only exposes the stable interaction surface: authorization, logging, and read-only retrieval.\n * @dev Storage structures (arrays, mappings) remain in the implementation, not in the interface.\n */\ninterface IAuditLog {\n    enum EventType {\n        CONSENT_GRANTED,\n        CONSENT_REVOKED,\n        CONSENT_CHECKED,\n        IDENTITY_REGISTERED,\n        IDENTITY_UPDATED,\n        DATA_REQUEST_REJECTED\n    }\n\n    struct AuditEntry {\n        address accessorUserId;\n        address subjectUserId;\n        bytes32 hashedScope;\n        uint256 unixTimestamp;\n        EventType eventType;\n    }\n\n    // -------------------------\n    // Logging\n    // -------------------------\n\n    /**\n     * @notice Write a log entry.\n     * @dev Only authorized loggers (set by admin) may call this.\n     */\n    function logEvent(AuditEntry calldata entry) external;\n\n    // -------------------------\n    // Authorization\n    // -------------------------\n\n    /**\n     * @notice Check whether a given address is allowed to write audit entries.\n     */\n    function isAuthorizedLogger(address logger) external view returns (bool);\n\n    /**\n     * @notice Grant logging permission to a given address.\n     * @dev Only admin may call this.\n     */\n    function authorizeLogger(address logger) external;\n\n    /**\n     * @notice Revoke logging permission.\n     * @dev Only admin may call this.\n     */\n    function revokeLogger(address logger) external;\n\n    // -------------------------\n    // Read-Only Ops\n    // -------------------------\n\n    /**\n     * @notice Return a specific audit entry.\n     */\n    function getAuditEntry(uint256 entryId)\n        external\n        view\n        returns (AuditEntry memory);\n\n    /**\n     * @notice Return total number of log entries.\n     */\n    function getLogsCount() external view returns (uint256);\n\n    /**\n     * @notice Return all log indices associated with a subject (user).\n     */\n    function getAccessHistory(address user)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice Return all log indices associated with an accessor.\n     */\n    function getAccessorHistory(address accessor)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice Return a contiguous range of log entries.\n     */\n    function getAuditEntries(uint256 startId, uint256 count)\n        external\n        view\n        returns (AuditEntry[] memory);\n\n    /**\n     * @notice Return the last N log entries.\n     */\n    function getRecentLogs(uint256 count)\n        external\n        view\n        returns (AuditEntry[] memory);\n}\n\n/**\n * @title AuditLog\n * @notice Concrete implementation of IAuditLog for audit trail storage.\n */\ncontract AuditLog is IAuditLog {\n    address public admin;\n    AuditEntry[] private auditEntries;\n    \n    mapping(address => uint256[]) private subjectAccessHistory;\n    mapping(address => uint256[]) private accessorAccessHistory;\n    mapping(address => bool) private authorizedLoggers;\n    \n    event LoggerAuthorized(address indexed logger);\n    event LoggerRevoked(address indexed logger);\n    event AuditEntryLogged(uint256 indexed entryId, address indexed accessor, address indexed subject);\n    \n    error Unauthorized();\n    error InvalidRange();\n    \n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin\");\n        _;\n    }\n    \n    modifier onlyAuthorizedLogger() {\n        if (!authorizedLoggers[msg.sender]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n    \n    constructor() {\n        admin = msg.sender;\n        authorizedLoggers[msg.sender] = true;\n    }\n    \n    function logEvent(AuditEntry calldata entry) external onlyAuthorizedLogger {\n        uint256 entryId = auditEntries.length;\n        auditEntries.push(entry);\n        \n        subjectAccessHistory[entry.subjectUserId].push(entryId);\n        accessorAccessHistory[entry.accessorUserId].push(entryId);\n        \n        emit AuditEntryLogged(entryId, entry.accessorUserId, entry.subjectUserId);\n    }\n    \n    function isAuthorizedLogger(address logger) external view returns (bool) {\n        return authorizedLoggers[logger];\n    }\n    \n    function authorizeLogger(address logger) external onlyAdmin {\n        require(logger != address(0), \"Invalid logger address\");\n        authorizedLoggers[logger] = true;\n        emit LoggerAuthorized(logger);\n    }\n    \n    function revokeLogger(address logger) external onlyAdmin {\n        authorizedLoggers[logger] = false;\n        emit LoggerRevoked(logger);\n    }\n    \n    function getAuditEntry(uint256 entryId) external view returns (AuditEntry memory) {\n        require(entryId < auditEntries.length, \"Entry does not exist\");\n        return auditEntries[entryId];\n    }\n    \n    function getLogsCount() external view returns (uint256) {\n        return auditEntries.length;\n    }\n    \n    function getAccessHistory(address user) external view returns (uint256[] memory) {\n        return subjectAccessHistory[user];\n    }\n    \n    function getAccessorHistory(address accessor) external view returns (uint256[] memory) {\n        return accessorAccessHistory[accessor];\n    }\n    \n    function getAuditEntries(uint256 startId, uint256 count) external view returns (AuditEntry[] memory) {\n        if (startId >= auditEntries.length) {\n            revert InvalidRange();\n        }\n        \n        uint256 endId = startId + count;\n        if (endId > auditEntries.length) {\n            endId = auditEntries.length;\n        }\n        \n        uint256 resultCount = endId - startId;\n        AuditEntry[] memory result = new AuditEntry[](resultCount);\n        \n        for (uint256 i = 0; i < resultCount; i++) {\n            result[i] = auditEntries[startId + i];\n        }\n        \n        return result;\n    }\n    \n    function getRecentLogs(uint256 count) external view returns (AuditEntry[] memory) {\n        uint256 totalLogs = auditEntries.length;\n        if (totalLogs == 0) {\n            return new AuditEntry[](0);\n        }\n        \n        uint256 resultCount = count > totalLogs ? totalLogs : count;\n        uint256 startId = totalLogs - resultCount;\n        \n        AuditEntry[] memory result = new AuditEntry[](resultCount);\n        for (uint256 i = 0; i < resultCount; i++) {\n            result[i] = auditEntries[startId + i];\n        }\n        \n        return result;\n    }\n}\n"
      },
      "project/contracts/ConsentManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IConsentManager {\n    function grantConsent(\n        address lender,\n        bytes32[] calldata scopes,\n        uint256 durationDays\n    ) external returns (bytes32 consentId);\n\n    function revokeAllConsents(address lender) external;\n\n    function revokeConsentById(bytes32 consentId) external;\n\n    function checkConsent(\n        address borrower,\n        bytes32 scope\n    ) external view returns (bool);\n\n    function isConsentValid(bytes32 consentId) external view returns (bool);\n\n    // ---------------------------------------------\n    // Accessors\n    // ---------------------------------------------\n\n    function getScopes(bytes32 consentId)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getConsents(bytes32 consentId)\n        external\n        view\n        returns (\n            address borrower,\n            address lender,\n            uint256 startBlockTime,\n            uint256 expiryBlockTime,\n            bool isRevoked\n        );\n\n    function getBorrowerConsents(address borrower)\n        external\n        view\n        returns (bytes32[] memory);\n}\n\n\n/**\n * @title ConsentManager\n * @notice Manages borrower consent grants and validates authorization requests from lenders\n * @dev Implements scope-based consent with expiry times and revocation capability\n */\ncontract ConsentManager {\n    struct Consent {\n        address borrower;\n        address lender;\n        // hashed scope identifiers \n        // e.g.: keccak256(abi.encodePacked(\"credit_score\", \"income_bracket\", ...))\n        bytes32[] scopes;\n        uint256 startBlockTime;\n        uint256 expiryBlockTime;\n        bool isRevoked;\n    }\n  \n    // borrowerAddress => consentIds[]\n    mapping(address => bytes32[]) public borrowerConsents;\n    // consentId => Consent\n    mapping(bytes32 => Consent) public consents;\n    \n    event ConsentGranted(\n        bytes32 indexed consentId,\n        address indexed borrower,\n        address indexed lender,\n        bytes32[] scopes,\n        uint256 startBlockTime,\n        uint256 expiryBlockTime\n    );\n    \n    event ConsentRevoked(\n        bytes32 indexed consentId,\n        address indexed borrower,\n        address indexed lender\n    );\n    \n    event ConsentQueried(\n        bytes32 indexed consentId,\n        address indexed querier,\n        bool authorized\n    );\n    \n    error UnauthorizedRevocation();\n    error ConsentAlreadyRevoked();\n    error ConsentExpired();\n    error ConsentNotFound();\n    \n    /**\n     * @notice Grant consent to a lender for multiple scopes and duration\n     * @param lender Address of the lender receiving consent\n     * @param scopes Array of hashed scope identifiers (e.g., keccak256(abi.encodePacked(\"credit_score\")))\n     * @param durationSeconds Duration in seconds for which consent is valid\n     * @return consentId Unique identifier for this consent grant\n     */\n    function grantConsent(\n        address lender,\n        bytes32[] calldata scopes,\n        uint256 durationSeconds\n    ) external returns (bytes32 consentId) {\n        require(lender != address(0), \"Invalid lender address\");\n        require(scopes.length > 0, \"At least one scope required\");\n        require(durationSeconds > 0, \"Duration must be positive\");\n        \n        // Validate no zero scopes\n        for (uint256 i = 0; i < scopes.length; i++) {\n            require(scopes[i] != bytes32(0), \"Invalid scope\");\n        }\n        \n        uint256 startBlockTime = block.timestamp;\n        uint256 expiryBlockTime = block.timestamp + durationSeconds;\n        \n        consentId = keccak256(\n            abi.encodePacked(\n                // `msg.sender` is `borrower`\n                msg.sender,\n                lender,\n                scopes,\n                block.timestamp,\n                block.number\n            )\n        );\n        \n\n        consents[consentId] = Consent({\n            borrower: msg.sender,\n            lender: lender,\n            scopes: scopes,\n            startBlockTime: startBlockTime,\n            expiryBlockTime: expiryBlockTime,\n            isRevoked: false\n        });\n        \n        borrowerConsents[msg.sender].push(consentId);\n        \n        emit ConsentGranted(consentId, msg.sender, lender, scopes, startBlockTime, expiryBlockTime);\n    }\n    \n    /**\n     * @notice Check if a specific consent is currently valid\n     * @param consentId The consent identifier to check\n     * @return bool True if consent exists, is not revoked, and not expired\n     */\n    function isConsentValid(bytes32 consentId) external view returns (bool) {\n        Consent storage consent = consents[consentId];\n        \n        if (consent.borrower == address(0)) {\n            return false;  // Consent doesn't exist\n        }\n        \n        if (consent.isRevoked) {\n            return false;  // Consent was revoked\n        }\n        \n        if (block.timestamp > consent.expiryBlockTime) {\n            return false;  // Consent expired\n        }\n        \n        return true;\n    }\n    \n    /**\n     * @notice Check authorization for a lender to access borrower's data with specific scope\n     * @dev Called by OffChainStore to validate consent before returning encrypted data\n     * @param borrower Address of the data owner\n     * @param scope The scope being requested\n     * @return bool True if valid consent exists from borrower to caller with requested scope\n     */\n    function checkConsent(\n        address borrower,   \n        bytes32 scope\n    ) external returns (bool) {\n        address lender = msg.sender;\n        \n        for (uint256 i = 0; i < borrowerConsents[borrower].length; i++) {\n            bytes32 consentId = borrowerConsents[borrower][i];\n            Consent storage consent = consents[consentId];\n            \n            if (consent.lender != lender || consent.isRevoked || block.timestamp > consent.expiryBlockTime) {\n                continue;\n            }\n            \n            bool scopeFound = false;\n            for (uint256 j = 0; j < consent.scopes.length; j++) {\n                if (consent.scopes[j] == scope) {\n                    scopeFound = true;\n                    break;\n                }\n            }\n            \n            if (scopeFound) {\n                emit ConsentQueried(consentId, lender, true);\n                return true;\n            }\n        }\n        \n        // No valid consent found for this scope\n        emit ConsentQueried(bytes32(0), lender, false);\n        return false;\n    }\n    \n    /**\n     * @notice Revoke all consents granted to a specific lender\n     * @param lender Address of the lender whose consents should be revoked\n     */\n    function revokeAllConsents(address lender) external {\n        require(lender != address(0), \"Invalid lender address\");\n        \n        bytes32[] storage userConsents = borrowerConsents[msg.sender];\n        \n        for (uint256 i = 0; i < userConsents.length; i++) {\n            bytes32 consentId = userConsents[i];\n            Consent storage consent = consents[consentId];\n            \n            if (consent.lender == lender && !consent.isRevoked) {\n                consent.isRevoked = true;\n                emit ConsentRevoked(consentId, msg.sender, lender);\n            }\n        }\n    }\n\n    /**\n     * @notice Revoke a specific consent by ID\n     * @param consentId The unique identifier of the consent to revoke\n     */\n    function revokeConsentById(bytes32 consentId) external {\n        Consent storage consent = consents[consentId];\n        \n        if (consent.borrower == address(0)) {\n            revert ConsentNotFound();\n        }\n        \n        if (consent.borrower != msg.sender) {\n            revert UnauthorizedRevocation();\n        }\n        \n        if (consent.isRevoked) {\n            revert ConsentAlreadyRevoked();\n        }\n        \n        consent.isRevoked = true;\n        emit ConsentRevoked(consentId, msg.sender, consent.lender);\n    }\n\n    function getScopes(bytes32 consentId) external view returns (bytes32[] memory) {\n        return consents[consentId].scopes;\n    }\n\n    function getBorrowerConsents(address borrower) external view returns (bytes32[] memory) {\n        return borrowerConsents[borrower];\n    }\n}\n"
      },
      "project/contracts/CreditRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./ConsentManager.sol\";\nimport \"./AuditLog.sol\";\n\n/**\n * @title ICreditRegistry\n * @notice Minimal interface defining public on-chain identity attributes.\n * @dev Responsibility boundaries:\n *      - CreditRegistry stores public categorical attributes + hashed commitments to off-chain data.\n *      - ConsentManager performs authorization checks for off-chain sensitive data access.\n *      - Off-chain systems must check consent before serving sensitive data referenced by hashes.\n *      - On-chain attributes are intentionally public; no consent required to read them.\n */\ninterface ICreditRegistry {\n    struct IdentityAttributes {\n        address userId;\n        bytes32 emailHash;\n        string creditTier;\n        string incomeBracket;\n        string debtRatioBracket;\n        uint256 lastUpdated;\n    }\n\n    event IdentityAttributesRegistered(\n        address indexed userId,\n        uint256 unixTimestamp\n    );\n    event IdentityAttributesUpdated(\n        address indexed user,\n        uint256 unixTimestamp\n    );\n\n    error InvalidConsentManager();\n    error UnauthorizedUpdate();\n    error IdentityAttributesNotFound();\n\n    /**\n     * @notice Register identity attributes (first-time initialization).\n     * @dev Must be called by the user whose attributes are being registered.\n     */\n    function registerIdentityAttributes(\n        bytes32 emailHash,\n        string calldata creditTier,\n        string calldata incomeBracket,\n        string calldata debtRatioBracket,\n        bytes32 accountReferenceHash\n    ) external;\n\n    /**\n     * @notice Update existing identity attributes selectively.\n     * @dev Only the user may update their own attributes.\n     */\n    function updateIdentityAttributes(\n        bytes32 emailHash,\n        string calldata creditTier,\n        string calldata incomeBracket,\n        string calldata debtRatioBracket\n    ) external;\n\n    // ------------------------------\n    // Ungated Commitment Access\n    // ------------------------------\n\n    // TODO these seem a waste of bytecode, kept for convenience\n\n    /**\n     * @notice Return hashed pointer to off-chain data.\n     * @dev Off-chain system must perform its own consent check before using this.\n     */\n    function getAccountReferenceHash(address user)\n        external\n        view\n        returns (bytes32);\n\n    /**\n     * @notice Return full on-chain identity metadata.\n     * @dev Provides only hashed or categorical values; no raw PII exists on-chain.\n     */\n    function getIdentityAttributes(address user)\n        external\n        view\n        returns (IdentityAttributes memory);\n\n    /**\n     * @notice Query whether a user has registered any identity attributes.\n     */\n    function hasIdentityAttributes(address user)\n        external\n        view\n        returns (bool);\n}\n\n\n/**\n * @title CreditRegistry\n * @notice Stores public categorical identity attributes and hashed commitments to off-chain sensitive data\n * @dev Categorical tiers (CreditTier, IncomeBracket, DebtRatioBracket) are intentionally coarse, public, and readable\n * @dev Hashed commitments (Email, AccountReference) bind off-chain sensitive data without revealing it\n * @dev Consent enforcement happens at the off-chain boundary; on-chain attributes are public by design\n */\ncontract CreditRegistry is ICreditRegistry {\n    mapping(address => IdentityAttributes) public identityAttributes;\n    mapping(address => bytes32) public accountReferenceHashes;  \n    ConsentManager public consentManager;\n    AuditLog public auditLog;\n\n    /**\n     * @notice Constructor to set the ConsentManager address\n     * @param _consentManager Address of the ConsentManager contract\n     */\n    constructor(address _consentManager) {\n        require(_consentManager != address(0), \"Invalid ConsentManager address\");\n        consentManager = ConsentManager(_consentManager);\n    }\n\n    /**\n     * @notice Set the AuditLog contract address\n     * @param _auditLog Address of the AuditLog contract\n     */\n    function setAuditLog(address _auditLog) external {\n        require(_auditLog != address(0), \"Invalid AuditLog address\");\n        auditLog = AuditLog(_auditLog);\n    }\n\n    /**\n     * @notice Register identity attributes for a user (first time)\n     * @param emailHash Hashed email address\n     * @param creditTier Readable credit tier (e.g., \"A\", \"B\", \"C\")\n     * @param incomeBracket Readable income bracket (e.g., \"50k-75k\", \"75k-100k\")\n     * @param debtRatioBracket Readable debt ratio bracket (e.g., \"0-20%\", \"20-40%\")\n     * @param accountReferenceHash Hashed pointer to off-chain encrypted data storage\n     */\n    function registerIdentityAttributes(\n        bytes32 emailHash,\n        string calldata creditTier,\n        string calldata incomeBracket,\n        string calldata debtRatioBracket,\n        bytes32 accountReferenceHash\n    ) external {\n        require(emailHash != bytes32(0), \"Invalid email hash\");\n        require(bytes(creditTier).length > 0, \"Invalid credit tier\");\n        require(accountReferenceHash != bytes32(0), \"Account reference hash required\");\n        \n        require(identityAttributes[msg.sender].userId == address(0), \"Identity attributes already registered\");\n        \n        identityAttributes[msg.sender] = IdentityAttributes({\n            userId: msg.sender,\n            emailHash: emailHash,\n            creditTier: creditTier,\n            incomeBracket: incomeBracket,\n            debtRatioBracket: debtRatioBracket,\n            lastUpdated: block.timestamp\n        });\n        \n        accountReferenceHashes[msg.sender] = accountReferenceHash;\n        \n        // Log to AuditLog if set\n        if (address(auditLog) != address(0)) {\n            auditLog.logEvent(IAuditLog.AuditEntry({\n                accessorUserId: msg.sender,\n                subjectUserId: msg.sender,\n                hashedScope: bytes32(0),\n                unixTimestamp: block.timestamp,\n                eventType: IAuditLog.EventType.IDENTITY_REGISTERED\n            }));\n        }\n        \n        emit IdentityAttributesRegistered(msg.sender, block.timestamp);\n    }\n    \n    /**\n     * @notice Update existing identity attributes for a user\n     * @param emailHash Hashed email address (optional, pass bytes32(0) to skip)\n     * @param creditTier Readable credit tier (optional, pass empty string to skip)\n     * @param incomeBracket Readable income bracket (optional, pass empty string to skip)\n     * @param debtRatioBracket Readable debt ratio bracket (optional, pass empty string to skip)\n     */\n    function updateIdentityAttributes(\n        bytes32 emailHash,\n        string calldata creditTier,\n        string calldata incomeBracket,\n        string calldata debtRatioBracket\n    ) external {\n        IdentityAttributes storage attrs = identityAttributes[msg.sender];\n        \n        if (attrs.userId == address(0)) {\n            revert IdentityAttributesNotFound();\n        }\n        \n        if (attrs.userId != msg.sender) {\n            revert UnauthorizedUpdate();\n        }\n        \n        // update fields\n        if (emailHash != bytes32(0)) {\n            attrs.emailHash = emailHash;\n        }\n        if (bytes(creditTier).length > 0) {\n            attrs.creditTier = creditTier;\n        }\n        if (bytes(incomeBracket).length > 0) {\n            attrs.incomeBracket = incomeBracket;\n        }\n        if (bytes(debtRatioBracket).length > 0) {\n            attrs.debtRatioBracket = debtRatioBracket;\n        }\n        \n        attrs.lastUpdated = block.timestamp;\n        \n        // Log to AuditLog if set\n        if (address(auditLog) != address(0)) {\n            auditLog.logEvent(IAuditLog.AuditEntry({\n                accessorUserId: msg.sender,\n                subjectUserId: msg.sender,\n                hashedScope: bytes32(0),\n                unixTimestamp: block.timestamp,\n                eventType: IAuditLog.EventType.IDENTITY_UPDATED\n            }));\n        }\n        \n        emit IdentityAttributesUpdated(msg.sender, block.timestamp);\n    }\n    \n    /**\n     * @notice Get account reference hash for a user\n     * @dev Off-chain system MUST verify consent via ConsentManager before using this hash to fetch sensitive data\n     * @param user Address of the user\n     * @return Account reference hash\n     */\n    function getAccountReferenceHash(address user) external view returns (bytes32) {\n        return accountReferenceHashes[user];\n    }\n    \n    /**\n     * @notice Get complete identity attributes for a user\n     * @param user Address of the user\n     * @return IdentityAttributes struct with all hashed data\n     */\n    function getIdentityAttributes(address user) external view returns (IdentityAttributes memory) {\n        IdentityAttributes storage attrs = identityAttributes[user];\n        require(attrs.userId != address(0), \"Identity attributes not found\");\n        return attrs;\n    }\n    \n    /**\n     * @notice Check if a user has registered identity attributes\n     * @param user Address to check\n     * @return bool True if user has registered identity attributes\n     */\n    function hasIdentityAttributes(address user) external view returns (bool) {\n        return identityAttributes[user].userId != address(0);\n    }\n}\n"
      }
    }
  }
}